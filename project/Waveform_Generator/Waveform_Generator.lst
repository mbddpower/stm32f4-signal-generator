
Waveform_Generator.elf:     file format elf32-littlearm
Waveform_Generator.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000041

Program Header:
    LOAD off    0x00010000 vaddr 0x08000000 paddr 0x08000000 align 2**16
         filesz 0x000001ac memsz 0x000001ac flags r-x
    LOAD off    0x00020000 vaddr 0x20000000 paddr 0x080001ac align 2**16
         filesz 0x00000010 memsz 0x00000020 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001ac  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  20000000  080001ac  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  20000010  080001bc  00020010  2**2
                  ALLOC
  3 .debug_info   00000406  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 0000015b  00000000  00000000  00020416  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  00020571  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_ranges 00000030  00000000  00000000  000205b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000000eb  00000000  00000000  000205e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000034e  00000000  00000000  000206cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000007f  00000000  00000000  00020a1a  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000033  00000000  00000000  00020a99  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000080  00000000  00000000  00020acc  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  .text	00000000 .text
20000000 l    d  .data	00000000 .data
20000010 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 Waveform_Generator.c
20000000 g       .data	00000000 __data_start__
080001ac g       .text	00000000 __etext
20000020 g       .debug_info	00000000 __HeapLimit
20000010 g       .bss	00000000 __bss_start__
08000040 g     F .text	00000050 Reset_Handler
08000000 g     O .text	00000040 vector_table
20000010 g       .data	00000000 __data_end__
20000020 g       .bss	00000000 __bss_end__
080000e8 g     F .text	00000002 Default_Handler
080000ec g     F .text	00000094 main
20000020 g       .debug_info	00000000 __end__
08000180 g     F .text	0000001a delay
08000090 g     F .text	00000058 _init_data
20020000 g       .bss	00000000 __StackTop
20020000 g       *ABS*	00000000 __stack
20020000 g       *ABS*	00000000 __StackLimit
20000000 g     O .data	00000010 iarray
0800019c g     O .text	00000010 carray
20000010 g     O .bss	00000010 uarray



Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 00 02 20 41 00 00 08 e9 00 00 08 e9 00 00 08     ... A...........
 8000010:	e9 00 00 08 e9 00 00 08 e9 00 00 08 00 00 00 00     ................
	...
 800002c:	e9 00 00 08 e9 00 00 08 00 00 00 00 e9 00 00 08     ................
 800003c:	e9 00 00 08                                         ....

08000040 <Reset_Handler>:
 * initializes data, bss sections and
 * calls main function.
 * It doesn't do any FPU initialization
 */
void Reset_Handler(void)
{
 8000040:	b508      	push	{r3, lr}
	/* initialize data and bss sections */
	_init_data();
 8000042:	f000 f825 	bl	8000090 <_init_data>

	/* Reset the RCC clock configuration to the default reset state */
	/* Set HSION bit */
	RCC->CR |= (1 << 0);
 8000046:	4b10      	ldr	r3, [pc, #64]	; (8000088 <Reset_Handler+0x48>)
 8000048:	681b      	ldr	r3, [r3, #0]
 800004a:	4a0f      	ldr	r2, [pc, #60]	; (8000088 <Reset_Handler+0x48>)
 800004c:	f043 0301 	orr.w	r3, r3, #1
 8000050:	6013      	str	r3, [r2, #0]

	/* Reset CFGR register */
	RCC->CFGR = 0x00000000;
 8000052:	4b0d      	ldr	r3, [pc, #52]	; (8000088 <Reset_Handler+0x48>)
 8000054:	2200      	movs	r2, #0
 8000056:	609a      	str	r2, [r3, #8]

	/* Reset HSEON (16), CSSON (19) and PLLON (24) bits */
	RCC->CR &= ~(uint32_t)((1 << 16) | (1 << 19) | (1 << 24));
 8000058:	4b0b      	ldr	r3, [pc, #44]	; (8000088 <Reset_Handler+0x48>)
 800005a:	681b      	ldr	r3, [r3, #0]
 800005c:	4a0a      	ldr	r2, [pc, #40]	; (8000088 <Reset_Handler+0x48>)
 800005e:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8000062:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000066:	6013      	str	r3, [r2, #0]

	/* Reset PLLCFGR register to reset value */
	RCC->PLLCFGR = 0x24003010;
 8000068:	4b07      	ldr	r3, [pc, #28]	; (8000088 <Reset_Handler+0x48>)
 800006a:	4a08      	ldr	r2, [pc, #32]	; (800008c <Reset_Handler+0x4c>)
 800006c:	605a      	str	r2, [r3, #4]

	/* Reset HSEBYP bit */
	RCC->CR &= ~(uint32_t)(1 << 18);
 800006e:	4b06      	ldr	r3, [pc, #24]	; (8000088 <Reset_Handler+0x48>)
 8000070:	681b      	ldr	r3, [r3, #0]
 8000072:	4a05      	ldr	r2, [pc, #20]	; (8000088 <Reset_Handler+0x48>)
 8000074:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000078:	6013      	str	r3, [r2, #0]

	/* Disable all interrupts */
	RCC->CIR = 0x00000000;
 800007a:	4b03      	ldr	r3, [pc, #12]	; (8000088 <Reset_Handler+0x48>)
 800007c:	2200      	movs	r2, #0
 800007e:	60da      	str	r2, [r3, #12]

	// main function
	main();
 8000080:	f000 f834 	bl	80000ec <main>

	// Wait forever
	for (;;);
 8000084:	e7fe      	b.n	8000084 <Reset_Handler+0x44>
 8000086:	bf00      	nop
 8000088:	40023800 	.word	0x40023800
 800008c:	24003010 	.word	0x24003010

08000090 <_init_data>:
/*************************************************
* Copy the data contents from LMA to VMA
* Initializes data and bss sections
*************************************************/
void _init_data(void)
{
 8000090:	b082      	sub	sp, #8
	extern unsigned long __etext, __data_start__, __data_end__, __bss_start__, __bss_end__;
	unsigned long *src = &__etext;
 8000092:	4b10      	ldr	r3, [pc, #64]	; (80000d4 <_init_data+0x44>)
 8000094:	9301      	str	r3, [sp, #4]
	unsigned long *dst = &__data_start__;
 8000096:	4b10      	ldr	r3, [pc, #64]	; (80000d8 <_init_data+0x48>)
 8000098:	9300      	str	r3, [sp, #0]

	/* ROM has data at end of text; copy it.  */
	while (dst < &__data_end__)
 800009a:	e007      	b.n	80000ac <_init_data+0x1c>
		*dst++ = *src++;
 800009c:	9a01      	ldr	r2, [sp, #4]
 800009e:	1d13      	adds	r3, r2, #4
 80000a0:	9301      	str	r3, [sp, #4]
 80000a2:	9b00      	ldr	r3, [sp, #0]
 80000a4:	1d19      	adds	r1, r3, #4
 80000a6:	9100      	str	r1, [sp, #0]
 80000a8:	6812      	ldr	r2, [r2, #0]
 80000aa:	601a      	str	r2, [r3, #0]
	while (dst < &__data_end__)
 80000ac:	9b00      	ldr	r3, [sp, #0]
 80000ae:	4a0b      	ldr	r2, [pc, #44]	; (80000dc <_init_data+0x4c>)
 80000b0:	4293      	cmp	r3, r2
 80000b2:	d3f3      	bcc.n	800009c <_init_data+0xc>

	/* zero bss.  */
	for (dst = &__bss_start__; dst< &__bss_end__; dst++)
 80000b4:	4b0a      	ldr	r3, [pc, #40]	; (80000e0 <_init_data+0x50>)
 80000b6:	9300      	str	r3, [sp, #0]
 80000b8:	e005      	b.n	80000c6 <_init_data+0x36>
		*dst = 0;
 80000ba:	9b00      	ldr	r3, [sp, #0]
 80000bc:	2200      	movs	r2, #0
 80000be:	601a      	str	r2, [r3, #0]
	for (dst = &__bss_start__; dst< &__bss_end__; dst++)
 80000c0:	9b00      	ldr	r3, [sp, #0]
 80000c2:	3304      	adds	r3, #4
 80000c4:	9300      	str	r3, [sp, #0]
 80000c6:	9b00      	ldr	r3, [sp, #0]
 80000c8:	4a06      	ldr	r2, [pc, #24]	; (80000e4 <_init_data+0x54>)
 80000ca:	4293      	cmp	r3, r2
 80000cc:	d3f5      	bcc.n	80000ba <_init_data+0x2a>
}
 80000ce:	bf00      	nop
 80000d0:	b002      	add	sp, #8
 80000d2:	4770      	bx	lr
 80000d4:	080001ac 	.word	0x080001ac
 80000d8:	20000000 	.word	0x20000000
 80000dc:	20000010 	.word	0x20000010
 80000e0:	20000010 	.word	0x20000010
 80000e4:	20000020 	.word	0x20000020

080000e8 <Default_Handler>:

// Default handler function
void Default_Handler(void)
{
	for (;;);  // Wait forever
 80000e8:	e7fe      	b.n	80000e8 <Default_Handler>
	...

080000ec <main>:

/*************************************************
* Main code starts from here
*************************************************/
int32_t main(void)
{
 80000ec:	b500      	push	{lr}
 80000ee:	b083      	sub	sp, #12
	// dummy copy. doesn't actually do anything
	// added to show where the variables are placed
	for(int i=0; i<4; i++){
 80000f0:	2300      	movs	r3, #0
 80000f2:	9301      	str	r3, [sp, #4]
 80000f4:	e012      	b.n	800011c <main+0x30>
		iarray[i] = carray[i];
 80000f6:	4a1c      	ldr	r2, [pc, #112]	; (8000168 <main+0x7c>)
 80000f8:	9b01      	ldr	r3, [sp, #4]
 80000fa:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80000fe:	491b      	ldr	r1, [pc, #108]	; (800016c <main+0x80>)
 8000100:	9b01      	ldr	r3, [sp, #4]
 8000102:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		uarray[i] = carray[i];
 8000106:	4a18      	ldr	r2, [pc, #96]	; (8000168 <main+0x7c>)
 8000108:	9b01      	ldr	r3, [sp, #4]
 800010a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800010e:	4918      	ldr	r1, [pc, #96]	; (8000170 <main+0x84>)
 8000110:	9b01      	ldr	r3, [sp, #4]
 8000112:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for(int i=0; i<4; i++){
 8000116:	9b01      	ldr	r3, [sp, #4]
 8000118:	3301      	adds	r3, #1
 800011a:	9301      	str	r3, [sp, #4]
 800011c:	9b01      	ldr	r3, [sp, #4]
 800011e:	2b03      	cmp	r3, #3
 8000120:	dde9      	ble.n	80000f6 <main+0xa>

	// Each module is powered separately. In order to turn on a module
	// we need to enable the relevant clock.
	// Set Bit 3 to enable GPIOD clock in AHB1ENR
	// AHB1ENR: XXXX XXXX XXXX XXXX XXXX XXXX XXXX 1XXX
	RCC->AHB1ENR |= 0x00000008;
 8000122:	4b14      	ldr	r3, [pc, #80]	; (8000174 <main+0x88>)
 8000124:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000126:	4a13      	ldr	r2, [pc, #76]	; (8000174 <main+0x88>)
 8000128:	f043 0308 	orr.w	r3, r3, #8
 800012c:	6313      	str	r3, [r2, #48]	; 0x30
	// We first need to AND it to reset them, then OR it to set them.
	//                     bit31                                         bit0
	// MODER register bits : 01 01 01 01 XX XX XX XX XX XX XX XX XX XX XX XX
	//                      p15                                           p0

	GPIOD->MODER &= 0x00FFFFFF;   // Reset bits 31-24 to clear old values
 800012e:	4b12      	ldr	r3, [pc, #72]	; (8000178 <main+0x8c>)
 8000130:	681b      	ldr	r3, [r3, #0]
 8000132:	4a11      	ldr	r2, [pc, #68]	; (8000178 <main+0x8c>)
 8000134:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000138:	6013      	str	r3, [r2, #0]
	GPIOD->MODER |= 0x55000000;   // Set MODER bits to 01 (0101 is 5 in hex)
 800013a:	4b0f      	ldr	r3, [pc, #60]	; (8000178 <main+0x8c>)
 800013c:	681b      	ldr	r3, [r3, #0]
 800013e:	4a0e      	ldr	r2, [pc, #56]	; (8000178 <main+0x8c>)
 8000140:	f043 43aa 	orr.w	r3, r3, #1426063360	; 0x55000000
 8000144:	6013      	str	r3, [r2, #0]
	// GPIOD->MODER &= ~(0xFF << 24); //or GPIOD->MODER &= ~(0b11111111 << 24);
	// GPIOD->MODER |=  (0x55 << 24); //or GPIOD->MODER |=  (0b01010101 << 24);

	// Set Pins 12-15 to 1 to turn on all LEDs
	// ODR: 1111 XXXX XXXX XXXX
	GPIOD->ODR |= 0xF000;
 8000146:	4b0c      	ldr	r3, [pc, #48]	; (8000178 <main+0x8c>)
 8000148:	695b      	ldr	r3, [r3, #20]
 800014a:	4a0b      	ldr	r2, [pc, #44]	; (8000178 <main+0x8c>)
 800014c:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8000150:	6153      	str	r3, [r2, #20]

	// You can do the same setup with shifting
	// GPIOD->ODR |= (0xF << 12);

	while(1){
		delay(LEDDELAY);
 8000152:	480a      	ldr	r0, [pc, #40]	; (800017c <main+0x90>)
 8000154:	f000 f814 	bl	8000180 <delay>
		GPIOD->ODR ^= 0xF000;  // Toggle LEDs
 8000158:	4b07      	ldr	r3, [pc, #28]	; (8000178 <main+0x8c>)
 800015a:	695b      	ldr	r3, [r3, #20]
 800015c:	4a06      	ldr	r2, [pc, #24]	; (8000178 <main+0x8c>)
 800015e:	f483 4370 	eor.w	r3, r3, #61440	; 0xf000
 8000162:	6153      	str	r3, [r2, #20]
		delay(LEDDELAY);
 8000164:	e7f5      	b.n	8000152 <main+0x66>
 8000166:	bf00      	nop
 8000168:	0800019c 	.word	0x0800019c
 800016c:	20000000 	.word	0x20000000
 8000170:	20000010 	.word	0x20000010
 8000174:	40023800 	.word	0x40023800
 8000178:	40020c00 	.word	0x40020c00
 800017c:	000c3500 	.word	0x000c3500

08000180 <delay>:
	return 0;
}

// A simple and not accurate delay function
void delay(volatile uint32_t s)
{
 8000180:	b082      	sub	sp, #8
 8000182:	9001      	str	r0, [sp, #4]
	for(s; s>0; s--){
 8000184:	9b01      	ldr	r3, [sp, #4]
 8000186:	e002      	b.n	800018e <delay+0xe>
 8000188:	9b01      	ldr	r3, [sp, #4]
 800018a:	3b01      	subs	r3, #1
 800018c:	9301      	str	r3, [sp, #4]
 800018e:	9b01      	ldr	r3, [sp, #4]
 8000190:	2b00      	cmp	r3, #0
 8000192:	d1f9      	bne.n	8000188 <delay+0x8>
		// Do nothing
	}
}
 8000194:	bf00      	nop
 8000196:	b002      	add	sp, #8
 8000198:	4770      	bx	lr
	...

0800019c <carray>:
 800019c:	0001 0000 0004 0000 0001 0000 0004 0000     ................
